package org.komparator.mediator.ws.cli;

import static javax.xml.ws.BindingProvider.ENDPOINT_ADDRESS_PROPERTY;

import java.util.List;
import java.util.Map;
import java.security.SecureRandom;
import java.math.BigInteger;
import org.komparator.security.handler.MessageIDHandler;
import java.util.concurrent.atomic.AtomicInteger;
import java.net.SocketTimeoutException;
import java.util.*;
import javax.xml.ws.*;
import static javax.xml.ws.BindingProvider.ENDPOINT_ADDRESS_PROPERTY;

import javax.xml.ws.BindingProvider;
import  javax.xml.ws.WebServiceException;

// TODO uncomment after generate-sources
import org.komparator.mediator.ws.*;

import pt.ulisboa.tecnico.sdis.ws.uddi.UDDINaming;
import org.komparator.security.domain.Security;

/**
 * Client.
 *
 * Adds easier endpoint address configuration and 
 * UDDI lookup capability to the PortType generated by wsimport.
 */
public class MediatorClient implements MediatorPortType {
    
    private static final String MEDIATOR_1 ="http://localhost:8071/mediator-ws/endpoint";
    // /** WS service */
    MediatorService service = null;

    // /** WS port (port type is the interface, port is the implementation) */
    MediatorPortType port = null;

    /** UDDI server URL */
    private String uddiURL = null;

    /** WS name */
    private String wsName = null;

    /** WS endpoint address */
    private String wsURL = null; // default value is defined inside WSDL

    private Map<String, Object> requestContext;
    //used to get unique messageIds
    private AtomicInteger msgIdCounter = new AtomicInteger(0);
    //helper in messageId setUP
    private boolean sameMsg =false;
    
   

    public String getWsURL() {
        return wsURL;
    }

    /** output option **/
    private boolean verbose = true;

    public boolean isVerbose() {
        return verbose;
    }

    public void setVerbose(boolean verbose) {
        this.verbose = verbose;
    }

    /** constructor with provided web service URL */
    public MediatorClient(String wsURL) throws MediatorClientException {
        this.wsURL = wsURL;
        buildSecurity();
        createStub();
    }

    /** constructor with provided UDDI location and name */
    public MediatorClient(String uddiURL, String wsName) throws MediatorClientException {
        this.uddiURL = uddiURL;
        this.wsName = wsName;
        buildSecurity();
        uddiLookup();
        createStub();
    }

    /** UDDI lookup */
    private void uddiLookup() throws MediatorClientException {
        try {
            if (verbose)
                System.out.printf("Contacting UDDI at %s%n", uddiURL);
            UDDINaming uddiNaming = new UDDINaming(uddiURL);

            if (verbose)
                System.out.printf("Looking for '%s'%n", wsName);
            wsURL = uddiNaming.lookup(wsName);

        } catch (Exception e) {
            String msg = String.format("Client failed lookup on UDDI at %s!",
                    uddiURL);
            throw new MediatorClientException(msg, e);
        }

        if (wsURL == null) {
            String msg = String.format(
                    "Service with name %s not found on UDDI at %s", wsName,
                    uddiURL);
            throw new MediatorClientException(msg);
        }
    }

    /** Stub creation and configuration */
    private void createStub() {
        if (verbose)
            System.out.println("Creating stub ...");

        service = new MediatorService();
        port = service.getMediatorPort();

        if (wsURL != null) {
            if (verbose)
                System.out.println("Setting endpoint address ...");
            BindingProvider bindingProvider = (BindingProvider) port;
            requestContext = bindingProvider.getRequestContext();
            requestContext.put(ENDPOINT_ADDRESS_PROPERTY, wsURL);
            //sets connection and receive time out
            timeOut(requestContext);
        }
        
    }
    public void buildSecurity(){
        Security sec = Security.getInstance();
        sec.setName("mediator-ws-cli");
    }


    // remote invocation methods ----------------------------------------------
    
    //Remote invocation methods with AT-MOST-ONCE -SEMANTIC implementation  
    //all remote invocations have a time-out, resend cycle with configurable time
    //non indempotent opeartions have a unique id so that server can check if is a new or repeated request
    //if is a new request execute and sends result to the client, if not, dosent execute and returns result obtained 
    //from last execution of that operation
   

    @Override
	public void clear() {
        //puts messageId on messageContext
        //operation that modifies the state of the application
        putToken();

        try{
            port.clear();
            sameMsg=false;
            return;
        }catch(WebServiceException wse){
            Throwable cause = wse.getCause();
            if (cause != null && cause instanceof SocketTimeoutException) {
                 System.out.println("The cause was a timeout exception: " + cause);
                 sameMsg=true;
                 clear();
            } 
            else {
                reConect();
                sameMsg=true;
                clear();
            }  
	    }
    }


    @Override
	public String ping(String arg0){

        putToken();  
        String str = "";
        try{
            str = port.ping(arg0);
            sameMsg=false;
            return str;
        }catch(WebServiceException wse){
            Throwable cause = wse.getCause();
            if (cause != null && cause instanceof SocketTimeoutException) {
                 System.out.println("The cause was a timeout exception: " + cause);
                 sameMsg=true;
                 return ping(arg0);
            } 
            else {
                reConect();
                sameMsg=true;
                return ping(arg0);
            }  
        }    
	}


    @Override
	public List<ItemView> searchItems(String descText) throws InvalidText_Exception {
        
        putToken();  
	    List<ItemView> lista= new ArrayList<ItemView>();
        try{
            lista= port.searchItems(descText);
            sameMsg=false;
            return lista;
        }catch(WebServiceException wse){
            Throwable cause = wse.getCause();
            if (cause != null && cause instanceof SocketTimeoutException) {
                 System.out.println("The cause was a timeout exception: " + cause);
                 sameMsg=true;
                 return searchItems(descText);
            } 
            else {
                reConect();
                sameMsg=true;
                return searchItems(descText);
            }  
        } 
    }


    @Override
	public List<CartView> listCarts() {

        putToken();  
        List<CartView> list = new ArrayList<CartView>();
        try{
            list = port.listCarts();
            sameMsg=false;
            return list;
        }catch(WebServiceException wse){
            Throwable cause = wse.getCause();
            if (cause != null && cause instanceof SocketTimeoutException) {
                 System.out.println("The cause was a timeout exception: " + cause);
                 sameMsg=true;
                 return listCarts();
            } 
            else {
                reConect();
                sameMsg=true;
                return listCarts();
            }  
        }      
	}


	@Override
	public List<ItemView> getItems(String productId) throws InvalidItemId_Exception {

        putToken();  
        List<ItemView> lista= new ArrayList<ItemView>();
        try{
            lista= port.getItems(productId);
            sameMsg=false;
            return lista;
        }catch(WebServiceException wse){
            Throwable cause = wse.getCause();
            if (cause != null && cause instanceof SocketTimeoutException) {
                 System.out.println("The cause was a timeout exception: " + cause);
                 sameMsg=true;
                 return getItems(productId);
            } 
            else {
                reConect();
                sameMsg=true;
                return getItems(productId);
            }  
        }
    }


	@Override
	public ShoppingResultView buyCart(String cartId, String creditCardNr)
		throws EmptyCart_Exception, InvalidCartId_Exception, InvalidCreditCard_Exception {

            //puts messageId on messageContext
            //operation that modifies the state of the application
            putToken(); 
            ShoppingResultView result = new ShoppingResultView();
            try{
                result= port.buyCart(cartId, creditCardNr);
                sameMsg=false;
                return result;
            }catch(WebServiceException wse){
                Throwable cause = wse.getCause();
                if (cause != null && cause instanceof SocketTimeoutException) {
                    System.out.println("The cause was a timeout exception: " + cause);
                    sameMsg=true;
                    return buyCart(cartId, creditCardNr);
                } 
                else {
                    reConect();
                    sameMsg=true;
                    return buyCart(cartId, creditCardNr);
                }  
            }
	}  


	@Override
	public void addToCart(String cartId, ItemIdView itemId, int itemQty) throws InvalidCartId_Exception,
		InvalidItemId_Exception, InvalidQuantity_Exception, NotEnoughItems_Exception {
        //puts messageId on messageContext
        //operation that modifies the state of the application
        putToken();     
        try{
            port.addToCart(cartId,itemId,itemQty);
            sameMsg=false;
            return;
        }catch(WebServiceException wse){
            Throwable cause = wse.getCause();
            if (cause != null && cause instanceof SocketTimeoutException) {
                System.out.println("The cause was a timeout exception: " + cause);
                sameMsg=true;
                addToCart(cartId, itemId, itemQty);
            } 
            else{
                reConect();
                sameMsg=true;
                addToCart(cartId, itemId, itemQty);
            }  
        }   
	}


	@Override
	public List<ShoppingResultView> shopHistory() {

        putToken();  
        List<ShoppingResultView> list = new ArrayList<ShoppingResultView>();
        try{
            list = port.shopHistory();
            sameMsg=false;
            return list;
        }catch(WebServiceException wse){
            Throwable cause = wse.getCause();
            if (cause != null && cause instanceof SocketTimeoutException) {
                System.out.println("The cause was a timeout exception: " + cause);
                sameMsg=true;
                return shopHistory();
            } 
            else{
                reConect();
                sameMsg=true;
                return shopHistory();
            }  
        }
	}
    /*-----------------------------------------------------------*/


    /*Update Methpds ---- OneWay ------From primary to Secundary Mediator*/
    @Override
    public void imAlive(){
        port.imAlive();
    }

    @Override
    public void updateShopHistory(ShoppingResultView shop, String id){
        port.updateShopHistory(shop,id);
    }

    @Override
    public void updateCart(String cartId, List<CartItemView> list, String id){
        port.updateCart(cartId,list,id);
    }

    @Override
    public void updateClear(String id){
        port.updateClear(id);
    }
    /*-------------------------------------------*/

    
    //sets connection timeout and receiveTimout betwween mediatorClient and mediator
    public void timeOut(Map<String, Object> requestContext){
            int connectionTimeout = 4000;
            // The connection timeout property has different names in different versions of JAX-WS
            // Set them all to avoid compatibility issues
            final List<String> CONN_TIME_PROPS = new ArrayList<String>();
            CONN_TIME_PROPS.add("com.sun.xml.ws.connect.timeout");
            CONN_TIME_PROPS.add("com.sun.xml.internal.ws.connect.timeout");
            CONN_TIME_PROPS.add("javax.xml.ws.client.connectionTimeout");
            // Set timeout until a connection is established (unit is milliseconds; 0 means infinite)
            for (String propName : CONN_TIME_PROPS)
                requestContext.put(propName, connectionTimeout);


            int receiveTimeout = 6000;
            // The receive timeout property has alternative names
            // Again, set them all to avoid compability issues
            final List<String> RECV_TIME_PROPS = new ArrayList<String>();
            RECV_TIME_PROPS.add("com.sun.xml.ws.request.timeout");
            RECV_TIME_PROPS.add("com.sun.xml.internal.ws.request.timeout");
            RECV_TIME_PROPS.add("javax.xml.ws.client.receiveTimeout");
            // Set timeout until the response is received (unit is milliseconds; 0 means infinite)
            for (String propName : RECV_TIME_PROPS)
                requestContext.put(propName, receiveTimeout);
    }

    //trys to reconnect to uddi when primary mediator dies
    public void reConect(){
        boolean connect;
        try{
            //gives a certain time for secundary mediator to regist
            Thread.sleep(5000);
        }catch(InterruptedException e){}

        try{
            connect=false;
            while(!connect){
                uddiLookup();
                if(!(wsURL.equals(MEDIATOR_1))){
                    //if new mediator is now registered creats stub to new wsURL
                    //if mediator isnt on uddi yet tries again and repeats cycle
                    createStub();
                    connect=true;
                }
            }
        }catch(MediatorClientException|WebServiceException e){
            System.out.println(e);
            reConect();
        }    
    }

    //puts messageID on messageContext
    public void putToken(){
        String initialValue = generateMsgId();
        requestContext.put(MessageIDHandler.REQUEST_PROPERTY, initialValue);
        System.out.println("client set id: " + initialValue +" on request message");

    }

    //returns a new messageID if is a new call
    //return same messageId if is a repeated call
    public String generateMsgId(){
        // relying on AtomicInteger to make sure assigned number is unique
        if(!sameMsg){
            int msgId = msgIdCounter.incrementAndGet();
            return Integer.toString(msgId);
        }
        else {
            int msgId = msgIdCounter.get();
            return Integer.toString(msgId);
        }
    }
    //sets maximum number of attempts to get a responde from server
    
}
